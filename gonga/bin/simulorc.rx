( simulorc.rx )

( ---- Anatomy ---- )

variable (liver) 126 allot 


: nope-nope-nope
	"\nnope " puts  ;

(liver) 127 
  [ 	
    over +
    &nope-nope-nope
    swap !
  ] iter drop

: (st) (liver) + ! ;

' dup   'D (st)
' swap  's (st)
' over  'o (st)
' drop  '. (st)
' rot   'r (st)
' pop   '{ (st)
' push  '} (st)

' +     '+ (st)
' -     '- (st)
' *     '* (st)
' /     '/ (st)
' =     '= (st)
' <     '< (st)
' >     '> (st)
' mod   '~ (st)
' not   '^ (st)
' and   'A (st)
' or    'O (st)
' xor   'N (st)

' do    'X (st)
' '     '' (st)
' h     'h (st)



( ---- Tawka ---- )

: hexabyte ( "hexes a byte" )
	dup 10 < 
		[ 48 + ] 
		[ 87 + ] if ;

: byte>cha ( byte -> < := cha true | byte false > -- := ?cha )
	( "filters out non-printable ascii" )
	dup 32 126 within ;

: half-heer 
	getc byte>cha 
		[ drop half-heer ] ifFalse ;

: heer ( nil -> cha )
	( "hear a werd" )
	getc byte>cha 
	[ 
		getc byte>cha 
		[ drop half-heer ] ifFalse ]
	[ drop heer ]
	if ;

: unspaz ( cha --> cha ) 
	( "space handling" ) 
	over 32 = 
		[ nip half-heer unspaz ] ifTrue ;

: numba?  ( cha -> flag ?numba )
	( "is the cha a numba?" )
	dup 97 103 within push ( a-f )
	    48 58  within pop ( 0-9 )
	or ;

: numba>byte ( numba -> byte )
	dup 97 103 within
	[ 87 - ]
	[ 48 - ] if ; 

: numbaz 
	"\nnumbaz!" puts 
	dup 32 =
	[ drop numba>byte ]
	[ numba>byte swap numba>byte 4 << + ] if
	"\nreached!" puts
	;

: bakpak "\nbakpak!" puts ;

: lettaz 
	"\nlettaz!  " puts .s 
	dup 32 =  
	 [ drop (liver) + @ do ]
	 [ bakpak ] if ;

: grk   ( comprehend )
	"\ngrokked!" puts
	over numba?
		[ numbaz ]
		[ lettaz ] if
	 ;

: grok heer unspaz grk ;


